#!/usr/bin/perl

# This snippet isn't intended as the final version, but is instead 
# a proof of concept for how to grab the dependency information for a
# module from all possible sources - Makfile, Build.PL, and META.yml.
# To be better, it should also stop at the top level dir - Module-Build,
# for instance, includes a sample Build.PL and META.yml in a subdirectory
# that we end up parsing because we are so lax in our scan.
#
# Like I said, as a proof of concept it works :)
#
# -mcummings

use strict;
use Cwd qw(getcwd abs_path cwd);
use YAML;
use YAML::Node;

use Data::Dumper;

use File::Basename;

my %req_list = ();
my $curdir = ".";

my %dep_list = ();
my $module_name = abs_path(".");
$module_name = basename($module_name);
&finder($curdir,$module_name);
print Dumper(%dep_list);
sub finder
{
    my ($workdir)  = shift;
    my $module_name = shift;
    my ($startdir) = &cwd;
    chdir($workdir) or die "Unable to enter dir $workdir:$!\n";
    opendir( CURD, "." );
    my @dirs = readdir(CURD);
    closedir(CURD);
    my %req_list = ();

    foreach my $object (@dirs) {
        next if ( $object eq "." );
        next if ( $object eq ".." );
        if ( -f $object ) {
            my $abs_path = abs_path($object);
            if ( $object =~ m/\.yml/ ) {

                # Do YAML parsing if you can
                    my $b_n = dirname($abs_path);
                    $b_n = basename($b_n);
                    my $arr  = YAML::LoadFile($abs_path);
                    foreach my $type qw(requires build_requires recommends) {
                        foreach my $module ( keys %{ $arr->{$type} } ) {
                            next if ( $module =~ /Cwd/i );
                            $dep_list{$module_name}{$module} = $arr->{$type}{$module};
                        }
                    }
            }
            if ( $object =~ m/^Makefile$/ ) {

                # Do some makefile parsing
                # RIPPED from CPAN.pm ;)
                use FileHandle;

                my $b_dir = dirname($abs_path);
                my $makefile = File::Spec->catfile( $b_dir, "Makefile" );

                my $fh;
                my (%p) = ();
                if ( $fh = FileHandle->new("<$makefile\0") ) {
                    local ($/) = "\n";
                    while (<$fh>) {
                        chomp;
                        last if /MakeMaker post_initialize section/;
                        my ($p) = m{^[\#]
       \s{0,}PREREQ_PM\s+=>\s+(.+)
       }x;
                        next unless $p;
                        while ( $p =~ m/(?:\s)([\w\:]+)=>q\[(.*?)\],?/g ) {
                            $dep_list{$module_name}{$1} = $2;
                        }

                        last;
                    }
                }
            }
            if ( $object eq "Build.PL" ) {

                # Do some Build file parsing
                use FileHandle;
                my $b_dir = dirname($abs_path);
                my $b_n   = dirname($abs_path);
                $b_n = basename($b_n);
                my $makefile = File::Spec->catfile( $b_dir, "Build.PL" );
                my (%p) = ();
                my $fh;

                foreach my $type qw(requires recommends build_requires) {
                    if ( $fh = FileHandle->new("<$makefile\0") ) {
                        local ($/) = "";
                        while (<$fh>) {
                            chomp;
                            my ($p) = m/^\s+$type\s+=>\s+\{(.*?)\}/smx;
                            next unless $p;
                            undef($/);

                            #local($/) = "\n";
                            my @list = split( ',', $p );
                            foreach my $pa (@list) {
                                $pa =~ s/\n|\s+|\'//mg;
                                if ($pa) {
                                    my ( $module, $vers ) = split( /=>/, $pa );
                                    $dep_list{$module_name}{$module} = "$vers";
                                }
                            }
                            last;

                        }
                    }
                }

            }

        }
        elsif ( -d $object ) {
            &finder($object, $module_name);
            next;
        }

    }
    chdir($startdir) or die "Unable to change to dir $startdir:$!\n";

}
