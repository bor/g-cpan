#!/usr/bin/perl -w
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
#

# modules to use - these will need to be marked as
# dependencies, and installable by portage
use strict;
use File::Spec;
use File::Path;
use File::Basename;
use File::Copy;
use Term::ANSIColor;
use Digest::MD5;
use Cwd qw(getcwd abs_path cwd);
use YAML;
use YAML::Node;

use constant MAKE_CONF    => '/etc/make.conf';
use constant PATH_PKG_VAR => '/var/db/pkg/';
##### CPAN CONFIG #####
use constant CPAN_CFG_DIR  => '.cpan/CPAN';
use constant CPAN_CFG_NAME => 'MyConfig.pm';

# defaults tools for CPAN Config
use constant DEF_FTP_PROG      => '/usr/bin/ftp';
use constant DEF_GPG_PROG      => '/usr/bin/gpg';
use constant DEF_GZIP_PROG     => '/bin/gzip';
use constant DEF_LYNX_PROG     => '/usr/bin/lynx';
use constant DEF_MAKE_PROG     => '/usr/bin/make';
use constant DEF_NCFTPGET_PROG => '/usr/bin/ncftpget';
use constant DEF_LESS_PROG     => '/usr/bin/less';
use constant DEF_TAR_PROG      => '/bin/tar';
use constant DEF_UNZIP_PROG    => '/usr/bin/unzip';
use constant DEF_WGET_PROG     => '/usr/bin/wget';
use constant DEF_BASH_PROG     => '/bin/bash';

##### ERRORS constants (easy internationalisation ;-) #####
use constant ERR_FILE_NOTFOUND   => "Couldn't find file '%s'";      # filename
use constant ERR_FOLDER_NOTFOUND => "Couldn't find folder '%s'";    # foldername
use constant ERR_OPEN_READ       =>
  "Couldn't open (read) file '%s' : %s";    # filename, $!
use constant ERR_OPEN_WRITE =>
  "Couldn't open (write) file '%s' : %s";    # filename, $!
use constant ERR_FOLDER_OPEN =>
  "Couldn't open folder '%s', %s";           # foldername, $!
use constant ERR_FOLDER_CREATE =>
  "Couldn't create folder '%s' : %s";        # foldername, $!

my $VERSION = "0.14.0";
my $prog    = basename($0);

my %dep_list  = ();
my @perl_dirs = (
    "dev-perl",   "perl-core", "perl-gcpan", "perl-text",
    "perl-tools", "perl-xml",  "perl-dev"
);

###############################
# Command line interpretation #
###############################

# Module load & configure
use Getopt::Long;
Getopt::Long::Configure("bundling");

# Init all options (has to be done to perform the 'sum test' later)
my ( $verbose, $search, $install, $upgrade, $generate, $list, $pretend, $ask ) =
  ( 0, 0, 0, 0, 0, 0, 0, 0 );

# Set colors here so we can use them at will anywhere :)
my $green = color("bold green");
my $white = color("bold white");
my $cyan  = color("bold cyan");
my $reset = color("reset");

#Get & Parse them
GetOptions(
    'verbose|v'  => \$verbose,
    'search|s'   => \$search,
    'install|i'  => \$install,
    'upgrade|u'  => \$upgrade,
    'list|l'     => \$list,
    'pretend|p'  => \$pretend,
    'ask|a'      => \$ask,
    'generate|g' => \$generate,
    'help|h'     => sub { exit_usage(); }
  )
  or exit_usage();

# Output error if more than one switch is activated
#
if ( $search + $list + $install + $generate + $upgrade + $ask > 1 ) {
    print_err("You can't combine actions with each other.\n");
    print
"${white}Please consult ${cyan}$prog ${green}--help${reset} or ${cyan}man $prog${reset} for more information\n\n";
    exit();
}

if ( $search + $list + $install + $generate + $upgrade + $pretend + $ask == 0 )
{
    print_err("You haven't told $prog what to do.\n");
    print
"${white}Please consult ${cyan}$prog ${green}--help${reset} or ${cyan}man $prog${reset} for more information\n\n";

    exit();
}

# Output error if no arguments
if ( ( scalar(@ARGV) == 0 ) and !( defined($upgrade) or defined($list) ) ) {
    print_err("Not even one module name or expression given !\n");
    print
"${white}Please consult ${cyan}$prog ${green}--help${reset} for more information\n\n";
    exit();
}

######################
# CPAN Special Stuff #
######################

# Do we need to generate a config ?
eval 'use CPAN::Config;';
my $needs_cpan_stub = $@ ? 1 : 0;

# Don't do autointalls via ExtUtils::AutoInstall

$ENV{PERL_EXTUTILS_AUTOINSTALL} = "--skipdeps";

# Test Replacement - ((A&B)or(C&B)) should be the same as ((A or C) and B)
if (   ( ($needs_cpan_stub) || ( $> > 0 ) )
    && ( !-f "$ENV{HOME}/.cpan/CPAN/MyConfig.pm" ) )
{

    # In case match comes from the UID test
    $needs_cpan_stub = 1;

    # Generate a fake config for CPAN
    cpan_stub();
}
else {
    $needs_cpan_stub = 0;
}

use CPAN;

##########
# main() #
##########

# Taking care of Searches. This has to be improved a lot, since it uses a call to
# CPAN Shell to do the job, thus making it impossible to have a clean output..
if ($search) {
    foreach my $expr (@ARGV) {

        # Assume they gave us module-name instead of module::name
        # which is bad, because CPAN can't convert it ;p

        print_ok("Searching for $expr on CPAN");
        unless ( CPAN::Shell->i("/$expr/") ) {
            $expr =~ s/-/::/g;
            CPAN::Shell->i("/$expr/");
        }
    }

    clean_up();
    exit;
}

# Confirm that there is an /etc/portage/categories file
# and that we have an entry for perl-gcpan in it.
my $cat_file = "/etc/portage/categories";
if ( -f "$cat_file" ) {

    #
    #  Use braces to localize the $/ assignment, so we don't get bitten later.
    #
    my $data;
    local $/ = undef;
    open( FH, "/etc/portage/categories" ) || die;
    $data = <FH>;
    close FH;
    unless ( grep "gcpan", $data ) {

        if ( open( CATEG, ">/etc/portage/categories" ) ) {
            print CATEG "perl-gcpan";
            close(CATEG);
        }
        else {
            print_err(
                "Insufficient permissions to edit /etc/portage/categories");
            print_err("Please run $prog as a user with sufficient permissions");
            exit;
        }
    }

}
else {
    if ( open( CATEG, ">/etc/portage/categories" ) ) {
        print CATEG "perl-gcpan";
        close(CATEG);
    }
    else {
        print_err("Insufficient permissions to edit /etc/portage/categories");
        print_err("Please run $prog as a user with sufficient permissions");
        exit;
    }
}

# Set our temporary overlay directory for the scope of this run.
# By setting an overlay directory, we bypass the predefined portage
# directory and allow portage to build a package outside of its
# normal tree.
my $tmp_overlay_dir;

my @ebuild_list;    #this array needs to be seriously observed.

# Set up global paths
my $PORTAGE_DIR     = getPortdir();
my $PORTAGE_DISTDIR = getPortDist();
my @OVERLAYS        = getOverlay();

unless ( scalar(@OVERLAYS) > 0 ) {
    if ( $generate or $pretend ) {
        print_err(
"The option you have chosen isn't supported without a configured overlay.\n"
        );
        exit();
    }
    unless ( $ENV{TMPDIR} ) { $ENV{TMPDIR} = '/var/tmp/g-cpan' }
    $tmp_overlay_dir = "$ENV{TMPDIR}/perl-modules_$$";

    # Create the tmp_overlay_dir in the even that it is a 'real' temp dir
    if ( not -d $tmp_overlay_dir ) {
        mkpath( $tmp_overlay_dir, 1, 0755 )
          or fatal( ERR_FOLDER_CREATE, $tmp_overlay_dir, $! );
    }
    push @OVERLAYS, $tmp_overlay_dir;
}

# o_reset will be used to catch if went through all of the overlay dirs successfully -
# open to better ways :) mcummings
my $o_reset = 1;

foreach my $o_dir (@OVERLAYS) {

    # See if we can create a file
    next if ( $o_dir =~ m/^$/ );
    if ( open( TMP, ">$o_dir/g-cpan-test" ) ) {
        close(TMP);
        unlink("$o_dir/g-cpan-test");
        $tmp_overlay_dir = $o_dir;
        $o_reset         = 0;
        if ($verbose) {
            print_info(
"Setting $tmp_overlay_dir as the PORTDIR_OVERLAY for this session."
            );
        }
        last;
    }
}
if ( $o_reset > 0 ) {
    print_err(
        "You don't have permission to work in any of the portage overlays.");
    print_err("Please run $prog as a user with sufficient permissions.\n");
    exit();
}

my @OVERLAY_PERLS;
my @PORTAGE_DEV_PERL;
my @TMP_DEV_PERL_DIRS;

foreach my $pdir (@perl_dirs) {
    my $tmp_dir = File::Spec->catdir( $PORTAGE_DIR, $pdir );
    push @PORTAGE_DEV_PERL, $tmp_dir;
    foreach my $odir (@OVERLAYS) {
        my $otmp = File::Spec->catdir( $odir, $pdir );
        push @OVERLAY_PERLS, $otmp;
    }
    my $vtmp_dir = File::Spec->catdir( PATH_PKG_VAR, $pdir );
    push @TMP_DEV_PERL_DIRS, $vtmp_dir;
}

# Create the ebuild in PORTDIR_OVERLAY, if it is defined and exists
# Part of this is to find an overlay the user running this session can actually write to

# Grab the whole available arches list, to include them later in ebuilds
print_info("Grabbing arch list") if $verbose;
my $arches = do {
    open my $tmp, "<$PORTAGE_DIR/profiles/arch.list"
      or fatal( ERR_OPEN_READ, "$PORTAGE_DIR/profiles/arch.list", $! );
    join " ", map { chomp; $_ } <$tmp>;
};

# Now we cat our dev-perl directory onto our overlay directory.
# This is done so that portage records the appropriate path
#i.e. dev-perl/package
my $perldev_overlay = File::Spec->catfile( $tmp_overlay_dir, 'perl-gcpan' );
if ( not -d $perldev_overlay ) {

    # create perldev overlay dir if not present
    mkpath( $perldev_overlay, 1, 0755 )
      or fatal( ERR_FOLDER_CREATE, $perldev_overlay, $! );
}

# Now we export our overlay directory into the session's env vars
$ENV{PORTDIR_OVERLAY} = $tmp_overlay_dir;

# Take care of List requests. This should return all the ebuilds managed by g-cpan
if ($list) {
    print_ok("Generating list of modules managed by g-cpan");
    my @managed = get_gcpans();
    exit();
}

if ($generate) {
    install_module($_) for (@ARGV);
}

if ($install) {
    install_module($_) for (@ARGV);
    emerge_module();
}

if ($upgrade) {
    if (@ARGV) {
        upgrade_module($_) for (@ARGV);
        emerge_module($_);
    }
    else {
        my @GLIST = get_gcpans();
        upgrade_module($_) for (@GLIST);
        emerge_module(@GLIST);
    }
}

clean_up();

exit;

##############

# Description:
# Returns the value of $param. Expects filecontents in $file.
# $valueOfKey = getParamFromFile($filecontents,$key);
# e.g.
# $valueOfKey = getParamFromFile(getFileContents("/path/to.ebuild","IUSE","firstseen");
sub getParamFromFile {
    my $file  = shift;
    my $param = shift;
    my $mode  = shift;   # ("firstseen","lastseen") - default is "lastseen"
    my $c     = 0;
    my $d     = 0;
    my @lines = ();
    my @aTmp  = ();      # temp (a)rray
    my $sTmp  = "";      # temp (s)calar
    my $text  = "";      # complete text/file after being cleaned up and striped
    my $value = "";      # value of $param
    my $this  = "";

    # - 1. split file in lines >
    @lines = split( /\n/, $file );

    # - 2 & 3 >
    for ( $c = 0 ; $c <= $#lines ; $c++ ) {

       # - 2. remove leading and trailing whitespaces and tabs from every line >
        $lines[$c] =~ s/^[ |\t]+//;    # leading whitespaces and tabs
        $lines[$c] =~ s/[ |\t]+$//;    # trailing whitespaces and tabs

        # - 3. remove comments >
        $lines[$c] =~ s/#(.*)//g;

        if ( $lines[$c] =~ /^$param="(.*)"/ ) {

            # single-line with quotationmarks >
            $value = $1;

            if ( $mode eq "firstseen" ) {

                # - 6. clean up value >
                $value =~ s/^[ |\t]+//;   # remove leading whitespaces and tabs
                $value =~ s/[ |\t]+$//;   # remove trailing whitespaces and tabs
                $value =~ s/\t/ /g;       # replace tabs with whitespaces
                $value =~
                  s/ {2,}/ /g;    # replace 1+ whitespaces with 1 whitespace
                return $value;
            }
        }
        elsif ( $lines[$c] =~ /^$param="(.*)/ ) {

            # multi-line with quotationmarks >
            $value = $1 . " ";
            for ( $d = $c + 1 ; $d <= $#lines ; $d++ ) {

                # - look for quotationmark >
                if ( $lines[$d] =~ /(.*)"/ ) {

                    # - found quotationmark; append contents and leave loop >
                    $value .= $1;
                    last;
                }
                else {

                    # - no quotationmark found; append line contents to $value >
                    $value .= $lines[$d] . " ";
                }
            }

            if ( $mode eq "firstseen" ) {

                # - 6. clean up value >
                $value =~ s/^[ |\t]+//;   # remove leading whitespaces and tabs
                $value =~ s/[ |\t]+$//;   # remove trailing whitespaces and tabs
                $value =~ s/\t/ /g;       # replace tabs with whitespaces
                $value =~
                  s/ {2,}/ /g;    # replace 1+ whitespaces with 1 whitespace
                return $value;
            }
        }
        elsif ( $lines[$c] =~ /^$param=(.*)/ ) {

            # - single-line without quotationmarks >
            $value = $1;

            if ( $mode eq "firstseen" ) {

                # - 6. clean up value >
                $value =~ s/^[ |\t]+//;   # remove leading whitespaces and tabs
                $value =~ s/[ |\t]+$//;   # remove trailing whitespaces and tabs
                $value =~ s/\t/ /g;       # replace tabs with whitespaces
                $value =~
                  s/ {2,}/ /g;    # replace 1+ whitespaces with 1 whitespace
                return $value;
            }
        }
    }

    # - 6. clean up value >
    $value =~ s/^[ |\t]+//;       # remove leading whitespaces and tabs
    $value =~ s/[ |\t]+$//;       # remove trailing whitespaces and tabs
    $value =~ s/\t/ /g;           # replace tabs with whitespaces
    $value =~ s/ {2,}/ /g;        # replace 1+ whitespaces with 1 whitespace

    return $value;
}

# Description:
# Returnvalue is the content of the given file.
# $filecontent = getFileContents($file);
sub getFileContents {
    my $content = "";

    open( FH, "<" . $_[0] ) || die( "Cannot open file " . $_[0] );
    while (<FH>) { $content .= $_; }
    close(FH);
    return $content;
}

# Description:
# @listOfEbuilds = getAvailableEbuilds($PORTDIR, category/packagename);
sub getAvailableEbuilds {
    my $PORTDIR     = shift;
    my $catPackage  = shift;
    my @packagelist = ();

    if ( -e $PORTDIR . "/" . $catPackage ) {

        # - get list of ebuilds >
        my $dh = new DirHandle( $PORTDIR . "/" . $catPackage );
        while ( defined( $_ = $dh->read ) ) {
            if ( $_ =~ m/(.+)\.ebuild$/ ) {
                push( @packagelist, $_ );
            }
        }
    }

    return @packagelist;
}

# Description:
# Returns version of an ebuild. (Without -rX string etc.)
# $version = getEbuildVersionSpecial("foo-1.23-r1.ebuild");
sub getEbuildVersionSpecial {
    my $ebuildVersion = shift;
    $ebuildVersion = substr( $ebuildVersion, 0, length($ebuildVersion) - 7 );
    $ebuildVersion =~
s/^([a-zA-Z0-9\-_\/\+]*)-([0-9\.]+[a-zA-Z]?)([\-r|\-rc|_alpha|_beta|_pre|_p]?)/$2$3/;

    return $ebuildVersion;
}

sub getCPANPackages {
    my $force_cpan_reload = shift;
    my $cpan_pn           = "";
    my @tmp_v             = ();

    if ($force_cpan_reload) {

        # - User forced reload of the CPAN index >
        CPAN::Index->force_reload();
    }

    for $mod ( CPAN::Shell->expand( "Module", "/./" ) ) {
        if ( defined $mod->cpan_version ) {

            # - Fetch CPAN-filename and cut out the filename of the tarball.
            #   We are not using $mod->id here because doing so would end up
            #   missing a lot of our ebuilds/packages >
            $cpan_pn = $mod->cpan_file;
            $cpan_pn =~ s|.*/||;

            if ( $mod->cpan_version eq "undef"
                && ( $cpan_pn =~ m/ / || $cpan_pn eq "" || !$cpan_pn ) )
            {

                # - invalid line - skip that one >
                next;
            }

            # - Right now both are "MODULE-FOO-VERSION-EXT" >
            my $cpan_version = $cpan_pn;

            # - Drop "-VERSION-EXT" from cpan_pn >
            $cpan_pn =~
              s/(?:-?)?(?:v?[\d\.]+[a-z]?)?\.(?:tar|tgz|zip|bz2|gz|tar\.gz)?$//;

            if ( length( lc($cpan_version) ) >= length( lc($cpan_pn) ) ) {

                # - Drop "MODULE-FOO-" from version >
                if ( length( lc($cpan_version) ) == length( lc($cpan_pn) ) ) {
                    $cpan_version = 0;
                }
                else {
                    $cpan_version = substr(
                        $cpan_version,
                        length( lc($cpan_pn) ) + 1,
                        length( lc($cpan_version) ) - length( lc($cpan_pn) ) - 1
                    );
                }
                if ( defined $cpan_version ) {
                    $cpan_version =~ s/\.(?:tar|tgz|zip|bz2|gz|tar\.gz)?$//;

    # - Remove any leading/trailing stuff (like "v" in "v5.2.0") we don't want >
                    $cpan_version =~ s/^[a-zA-Z]+//;
                    $cpan_version =~ s/[a-zA-Z]+$//;

                    # - Convert CPAN version >
                    @tmp_v = split( /\./, $cpan_version );
                    if ( $#tmp_v > 1 ) {
                        if ($DEBUG) {
                            print " converting version -> " . $cpan_version;
                        }
                        $cpan_version = $tmp_v[0] . ".";
                        for ( 1 .. $#tmp_v ) { $cpan_version .= $tmp_v[$_]; }
                        if ($DEBUG) { print " -> " . $cpan_version . "\n"; }
                    }

                    if ( $cpan_version eq "" ) { $cpan_version = 0; }

                    $modules{'cpan'}{$cpan_pn} = $cpan_version;
                    $modules{'cpan_lc'}{ lc($cpan_pn) } = $cpan_version;
                }
            }
        }
    }
    return 0;
}

sub getPortdir {
    my $portdir = getParamFromFile( getFileContents("/etc/make.conf"),
        "PORTDIR", "lastseen" );

    if ( !$portdir ) {
        $portdir = getParamFromFile( getFileContents("/etc/make.globals"),
            "PORTDIR", "lastseen" );
    }

    return $portdir;
}

sub getPortDist {
    my $portdist = getParamFromFile( getFileContents("/etc/make.conf"),
        "DISTDIR", "lastseen" );

    if ( !$portdist ) {
        $portdist = getParamFromFile( getFileContents("/etc/make.globals"),
            "DISTDIR", "lastseen" );
    }

    return $portdist;
}

sub getOverlay {
    my @overlay = [];
    my $overlay = getParamFromFile( getFileContents("/etc/make.conf"),
        "PORTDIR_OVERLAY", "lastseen" );

    if ( !$overlay ) {
        return;
    }
    else {
        if ( $overlay =~ m/\b\s*/ ) {
            @overlay = map { split ' ' } $overlay;
        }
        else {
            push @overlay, $overlay;
        }
    }
    return @overlay;
}
